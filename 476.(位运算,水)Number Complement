/************************************************************************************************/
Given a positive integer, output its complement number. The complement strategy is to flip the 
bits of its binary representation.

Note:
The given integer is guaranteed to fit within the range of a 32-bit signed integer.
You could assume no leading zero bit in the integer’s binary representation.
Example 1:
Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 
010. So you need to output 2.
Example 2:
Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.
So you need to output 0.

Note: 转为二进制, 按位取反, 返回对应的二进制的值
dummy为与num等长且各位均为1的数字, 求异或即为按位取反
/************************************************************************************************/
I. 
class Solution {
public:
    int findComplement(int num) {
        int tmp=num, dummy=1;
		while(tmp)
		{
			tmp>>=1;
			dummy<<=1;
		}
		return ((dummy-1)^num);
    }
};

II. Stupid
class Solution {
public:
    int findComplement(int num) {
        int sum=0;
		vector<int> bin;
		while(num)
		{
			bin.push_back(!(num%2));
			num>>=1;
		}
		reverse(bin.begin(), bin.end());
		int len=bin.size();
		for(int i=len-1; i>=0; i--)
		{
		    int tmp=(2<<(len-i-1))/2;
		    sum+=bin[i]*tmp;
		}
			//sum+=bin[i]*pow(2, len-i-1);
		return sum;
    }
};
